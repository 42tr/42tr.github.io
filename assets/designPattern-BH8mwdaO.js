import{b as f,B as t}from"./main-runtime-dom.esm-bundler-Dw6ihk_t.js";import{_ as c}from"./main-_plugin-vue_export-helper-DlAUqK2U.js";const p={};function d(h,a){return a[0]||(a[0]=f("<h1 data-v-8f7098fc>设计模式 &amp; Rust 实现</h1><p data-v-8f7098fc>设计模式是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。</p><p data-v-8f7098fc>设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。</p><h2 data-v-8f7098fc>设计模式的问题</h2><li data-v-8f7098fc>通常当所选编程语言或技术缺少必要的抽象功能时， 人们才需要设计模式。 在这种情况下， 模式是一种可为语言提供更优功能的蹩脚解决方案。 例如， 策略模式在绝大部分现代编程语言中可以简单地使用匿名 （lambda） 函数来实现。</li><li data-v-8f7098fc>模式试图将已经广泛使用的方式系统化。 许多人会将这样的统一化认为是某种教条， 他们会 “全心全意” 地实施这样的模式， 而不会根据项目的实际情况对其进行调整。</li><li data-v-8f7098fc>如果你只有一把铁锤， 那么任何东西看上去都像是钉子。这个问题常常会给初学模式的人们带来困扰： 在学习了某个模式后， 他们会在所有地方使用该模式， 即便是在较为简单的代码也能胜任的地方也是如此。</li><h2 data-v-8f7098fc>设计模式分类</h2><h3 data-v-8f7098fc>创建型模式</h3><p data-v-8f7098fc>提供创建对象的机制， 增加已有代码的灵活性和可复用性。</p><h4 data-v-8f7098fc>工厂模式</h4><p data-v-8f7098fc>优点：避免创建者和具体产品之间的紧密耦合；单一职责原则，可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护；开闭原则，无需更改现有客户端代码，你就可以在程序中引入新的产品类型。</p><h3 data-v-8f7098fc>结构型模式</h3><p data-v-8f7098fc>介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</p><h3 data-v-8f7098fc>行为模式</h3><p data-v-8f7098fc>负责对象间的高效沟通和职责委派。</p>",16))}const v=c(p,[["render",d],["__scopeId","data-v-8f7098fc"]]);t(v).mount("#app");
